Поиск по строкам приводит к функции sub_401775 (flag_check)
Там некие проверки и выдача Correct flag
~~~ C
__int64 __fastcall flag_check(int a1, _QWORD *a2, int a3, int a4, int a5, int a6)
{
  __int64 result; // rax
  char v7; // [rsp+1Bh] [rbp-535h]
  int i; // [rsp+1Ch] [rbp-534h]
  int j; // [rsp+20h] [rbp-530h]
  int k; // [rsp+24h] [rbp-52Ch]
  int v11; // [rsp+34h] [rbp-51Ch]
  char *v12; // [rsp+38h] [rbp-518h]
  _DWORD v13[322]; // [rsp+40h] [rbp-510h] BYREF
  unsigned __int64 v14; // [rsp+548h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  if ( a1 == 2 )
  {
    v12 = (char *)a2[1];
    if ( (unsigned int)j_ifunc_4228C0(v12) == 60 )
    {
      sub_40B080((v12[2] << 8) | (v12[1] << 16) | (*v12 << 24) | (unsigned int)v12[3]); // обёртка вокруг srand, задание seed на основе 4 первых значений вода
      memset(v13, 0, 0x400u);
      for ( i = 0; i <= 255; ++i ) // цикл перемешивания byte_4C6100
      {
        do
        {
          do
            v11 = (int)sub_40B740() % 256; // Получение псевдослучайного числа, sub_40B740 обёртка вокруг random
          while ( v11 == i ); // Число должно быть не равно i, чтобы не менять его самому с собой
        }
        while ( v13[v11] ); // Также нужно, чтобы мы это число ещё не использовали
        v13[v11] = 1;
        v7 = byte_4C6100[i]; // v7 - temp
        byte_4C6100[i] = byte_4C6100[v11];
        byte_4C6100[v11] = v7;
      }
      for ( j = 0; j < 60; ++j )
        *((_BYTE *)&v13[256] + j) = byte_4C6100[(unsigned __int8)v12[j] ^ 0x42];
      for ( k = 0; k < 60; ++k )
      {
        if ( *((_BYTE *)&v13[256] + k) != byte_4C6200[k] ) // Контрольная проверка
        {
          some_print("[-] Invalid flag!");
          result = 1;
          goto LABEL_19;
        }
      }
      some_print("[+] Correct flag!");
      result = 0;
    }
    else
    {
      some_print("[-] Invalid flag!");
      result = 1;
    }
  }
  else
  {
    sub_40BFA0((unsigned int)"Usage: %s <flag>\nFlag format: ctfcup{<data>}", *a2, a3, a4, a5, a6, (char)a2);
    result = 1;
  }
LABEL_19:
  if ( v14 != __readfsqword(0x28u) )
    sub_452940();
  return result;
}
~~~


Видно некие преобразования и действия с byte_4C6100 и byte_4C6200

Также сравнение с byte_4C6200, которое если мы проходим, то получаем "[+] Correct flag!", значит byte_4C6200 эта эталонная последовательность, которая является нашим флагом после всех преобразований.

sub_40B740 - обёртка вокруг glibc_random, понять это можно спустившись в неё и увидев внутри sub_40B6A0 константы 0x41C64E6D и 0x303, также по инициализации 31 словом и использование задержки, при генерации складывают два значения из кольцевого буфера, сохраняют результат и возвращают его сдвиг вправо на 1, что соответствует glibc random()

random выдаёт псевдослучайную последовательность на основе seedа, seed подаётся в него из 4х начальных байт ввода пользователем, на основе этой псевдослучайности  перемешивается 

byte_4C6100 в свою очередь это таблица подстановки (S-box), то есть уже некоторый набор байтов, который нужно расположить в правильном порядке, чтобы получить соответствие с  byte_4C6200. Для расположения используется как раз random(). Это для получения правильного порядка таблицы. А для того чтобы из этой таблицы выбрать нужные байты мы берём уже пользовательский ввод и XORим его с 0x42, и по этому индексу берём значение и пихаем в выше в v13. И тот уже сравнивается с эталонной последовательностью.

Для получения изначальной строки нам надо взять byte_4C6200, сопоставить с индексами правильно перемешанного byte_4C6100 (правильный его перемес получить легко, тк мы знаем формат флага). Там уже берём индекс этого элемента, XORим его с 0x42, и переводим в читабельный вид кодировкой.

~~~ python
from dataclasses import dataclass

byte_4C6100 = [147, 111, 196, 102, 201, 12, 222, 43, 1, 62, 49, 178, 151, 198, 166, 112, 10, 27, 6, 128, 180, 120, 142, 187, 2, 65, 88, 39, 225, 186, 159, 115, 157, 243, 255, 0, 52, 119, 164, 32, 138, 253, 123, 137, 66, 177, 56, 249, 143, 7, 85, 103, 8, 248, 133, 51, 223, 60, 99, 98, 59, 146, 25, 247, 209, 246, 179, 242, 236, 40, 183, 47, 67, 227, 193, 174, 192, 165, 97, 77, 162, 76, 94, 217, 71, 226, 72, 139, 20, 44, 79, 109, 203, 125, 215, 214, 154, 131, 105, 89, 73, 184, 63, 245, 175, 22, 173, 145, 239, 23, 84, 83, 202, 9, 80, 152, 237, 200, 69, 161, 16, 195, 124, 36, 127, 41, 24, 81, 26, 116, 213, 207, 101, 160, 130, 190, 218, 199, 11, 185, 15, 212, 90, 87, 167, 155, 100, 232, 229, 42, 205, 191, 106, 70, 228, 172, 91, 168, 211, 104, 182, 3, 96, 235, 129, 107, 208, 34, 171, 238, 141, 92, 45, 114, 122, 61, 21, 110, 231, 204, 126, 230, 140, 5, 181, 210, 18, 216, 33, 240, 136, 206, 234, 28, 75, 220, 132, 113, 78, 135, 17, 153, 50, 144, 95, 38, 170, 64, 57, 221, 149, 37, 244, 169, 224, 86, 194, 252, 250, 68, 30, 254, 14, 55, 35, 197, 46, 233, 93, 82, 176, 108, 13, 118, 251, 134, 4, 74, 19, 241, 29, 54, 53, 150, 58, 189, 121, 148, 117, 31, 158, 188, 48, 219, 163, 156]
byte_4C6200 = [2, 216, 113, 2, 212, 123, 38, 171, 229, 212, 81, 160, 113, 158, 81, 99, 216, 160, 81, 27, 39, 27, 81, 99, 27, 160, 2, 67, 190, 124, 124, 27, 32, 247, 27, 160, 158, 99, 160, 22, 229, 32, 27, 160, 2, 229, 32, 247, 81, 49, 216, 212, 124, 49, 216, 144, 36, 32, 99, 217]

class GlibcRandom: #Реализация рандома
    def __init__(self, seed):
        self.rand_deg = 31
        self.rand_sep = 3
        self.mod = 2147483647
        self.state = [0] * self.rand_deg
        self.fidx = 0
        self.ridx = 0
        self.seed(seed)

    def seed(self, seed):
        seed &= 0xffffffff
        if seed == 0:
            seed = 1
        self.state[0] = seed % self.mod
        val = seed % self.mod
        for i in range(1, self.rand_deg):
            val = (16807 * val) % self.mod
            self.state[i] = val
        self.fidx = self.rand_sep
        self.ridx = 0
        for _ in range(self.rand_deg * 10):
            self.random()

    def random(self):
        val = (self.state[self.fidx] + self.state[self.ridx]) & 0xffffffff
        self.state[self.fidx] = val
        res = (val >> 1) & 0x7fffffff
        self.fidx += 1
        if self.fidx >= self.rand_deg:
            self.fidx = 0
        self.ridx += 1
        if self.ridx >= self.rand_deg:
            self.ridx = 0
        return res

seed_chars = b"ctfc"
seed = (seed_chars[0] << 24) | (seed_chars[1] << 16) | (seed_chars[2] << 8) | seed_chars[3]
rng = GlibcRandom(seed)

sbox = byte_4C6100.copy()
used = [0]*256
for i in range(256):
    while True:
        v11 = rng.random() % 256
        if v11 != i and not used[v11]:
            break
    used[v11] = 1
    sbox[i], sbox[v11] = sbox[v11], sbox[i]

inverse = {value: idx for idx, value in enumerate(sbox)} 
# означает «построить словарь, где ключ — value, а значение — idx»

flag_bytes = []
for val in byte_4C6200:
    idx = inverse[val]
    flag_bytes.append(idx ^ 0x42)
flag = bytes(flag_bytes)
print(flag)
~~~